/**
 * Generated by orval v7.11.2 ðŸº
 * Do not edit manually.
 * ValueCell Server API
 * A community-driven, multi-agent platform for financial applications
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CurrencyFormatRequest,
  DateTimeFormatRequest,
  HTTPValidationError,
  LanguageDetectionRequest,
  LanguageRequest,
  NumberFormatRequest,
  TimezoneRequest,
  TranslationRequest,
  UserI18nSettingsRequest
} from './model';

import {
  faker
} from '@faker-js/faker';

import {
  HttpResponse,
  delay,
  http
} from 'msw';

import type {
  SuccessResponseAgentI18nContextData,
  SuccessResponseAppInfoData,
  SuccessResponseCurrencyFormatData,
  SuccessResponseDateTimeFormatData,
  SuccessResponseDict,
  SuccessResponseHealthCheckData,
  SuccessResponseI18nConfigData,
  SuccessResponseLanguageDetectionData,
  SuccessResponseNumberFormatData,
  SuccessResponseSupportedLanguagesData,
  SuccessResponseTimezonesData,
  SuccessResponseTranslationData,
  SuccessResponseUserI18nSettingsData
} from './model';

/**
 * Get ValueCell application basic information including name, version and environment
 * @summary Get application info
 */
export type rootGetResponse200 = {
  data: SuccessResponseAppInfoData
  status: 200
}
    
export type rootGetResponseComposite = rootGetResponse200;
    
export type rootGetResponse = rootGetResponseComposite & {
  headers: Headers;
}

export const getRootGetUrl = () => {


  

  return `/`
}

export const rootGet = async ( options?: RequestInit): Promise<rootGetResponse> => {
  
  const res = await fetch(getRootGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: rootGetResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as rootGetResponse
}



export const getRootGetQueryKey = () => {
    return [`/`] as const;
    }

    
export const getRootGetQueryOptions = <TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRootGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof rootGet>>> = ({ signal }) => rootGet({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type RootGetQueryResult = NonNullable<Awaited<ReturnType<typeof rootGet>>>
export type RootGetQueryError = unknown


export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof rootGet>>,
          TError,
          Awaited<ReturnType<typeof rootGet>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof rootGet>>,
          TError,
          Awaited<ReturnType<typeof rootGet>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get application info
 */

export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getRootGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get current internationalization configuration information
 * @summary Get i18n configuration
 */
export type getConfigI18nConfigGetResponse200 = {
  data: SuccessResponseI18nConfigData
  status: 200
}

export type getConfigI18nConfigGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getConfigI18nConfigGetResponseComposite = getConfigI18nConfigGetResponse200 | getConfigI18nConfigGetResponse422;
    
export type getConfigI18nConfigGetResponse = getConfigI18nConfigGetResponseComposite & {
  headers: Headers;
}

export const getGetConfigI18nConfigGetUrl = () => {


  

  return `/i18n/config`
}

export const getConfigI18nConfigGet = async ( options?: RequestInit): Promise<getConfigI18nConfigGetResponse> => {
  
  const res = await fetch(getGetConfigI18nConfigGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getConfigI18nConfigGetResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getConfigI18nConfigGetResponse
}



export const getGetConfigI18nConfigGetQueryKey = () => {
    return [`/i18n/config`] as const;
    }

    
export const getGetConfigI18nConfigGetQueryOptions = <TData = Awaited<ReturnType<typeof getConfigI18nConfigGet>>, TError = HTTPValidationError>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfigI18nConfigGet>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConfigI18nConfigGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConfigI18nConfigGet>>> = ({ signal }) => getConfigI18nConfigGet({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getConfigI18nConfigGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetConfigI18nConfigGetQueryResult = NonNullable<Awaited<ReturnType<typeof getConfigI18nConfigGet>>>
export type GetConfigI18nConfigGetQueryError = HTTPValidationError


export function useGetConfigI18nConfigGet<TData = Awaited<ReturnType<typeof getConfigI18nConfigGet>>, TError = HTTPValidationError>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfigI18nConfigGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConfigI18nConfigGet>>,
          TError,
          Awaited<ReturnType<typeof getConfigI18nConfigGet>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetConfigI18nConfigGet<TData = Awaited<ReturnType<typeof getConfigI18nConfigGet>>, TError = HTTPValidationError>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfigI18nConfigGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConfigI18nConfigGet>>,
          TError,
          Awaited<ReturnType<typeof getConfigI18nConfigGet>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetConfigI18nConfigGet<TData = Awaited<ReturnType<typeof getConfigI18nConfigGet>>, TError = HTTPValidationError>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfigI18nConfigGet>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get i18n configuration
 */

export function useGetConfigI18nConfigGet<TData = Awaited<ReturnType<typeof getConfigI18nConfigGet>>, TError = HTTPValidationError>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getConfigI18nConfigGet>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetConfigI18nConfigGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get list of all languages supported by the system
 * @summary Get supported languages
 */
export type getSupportedLanguagesI18nLanguagesGetResponse200 = {
  data: SuccessResponseSupportedLanguagesData
  status: 200
}
    
export type getSupportedLanguagesI18nLanguagesGetResponseComposite = getSupportedLanguagesI18nLanguagesGetResponse200;
    
export type getSupportedLanguagesI18nLanguagesGetResponse = getSupportedLanguagesI18nLanguagesGetResponseComposite & {
  headers: Headers;
}

export const getGetSupportedLanguagesI18nLanguagesGetUrl = () => {


  

  return `/i18n/languages`
}

export const getSupportedLanguagesI18nLanguagesGet = async ( options?: RequestInit): Promise<getSupportedLanguagesI18nLanguagesGetResponse> => {
  
  const res = await fetch(getGetSupportedLanguagesI18nLanguagesGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getSupportedLanguagesI18nLanguagesGetResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getSupportedLanguagesI18nLanguagesGetResponse
}



export const getGetSupportedLanguagesI18nLanguagesGetQueryKey = () => {
    return [`/i18n/languages`] as const;
    }

    
export const getGetSupportedLanguagesI18nLanguagesGetQueryOptions = <TData = Awaited<ReturnType<typeof getSupportedLanguagesI18nLanguagesGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSupportedLanguagesI18nLanguagesGet>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSupportedLanguagesI18nLanguagesGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSupportedLanguagesI18nLanguagesGet>>> = ({ signal }) => getSupportedLanguagesI18nLanguagesGet({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSupportedLanguagesI18nLanguagesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSupportedLanguagesI18nLanguagesGetQueryResult = NonNullable<Awaited<ReturnType<typeof getSupportedLanguagesI18nLanguagesGet>>>
export type GetSupportedLanguagesI18nLanguagesGetQueryError = unknown


export function useGetSupportedLanguagesI18nLanguagesGet<TData = Awaited<ReturnType<typeof getSupportedLanguagesI18nLanguagesGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSupportedLanguagesI18nLanguagesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSupportedLanguagesI18nLanguagesGet>>,
          TError,
          Awaited<ReturnType<typeof getSupportedLanguagesI18nLanguagesGet>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSupportedLanguagesI18nLanguagesGet<TData = Awaited<ReturnType<typeof getSupportedLanguagesI18nLanguagesGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSupportedLanguagesI18nLanguagesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSupportedLanguagesI18nLanguagesGet>>,
          TError,
          Awaited<ReturnType<typeof getSupportedLanguagesI18nLanguagesGet>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSupportedLanguagesI18nLanguagesGet<TData = Awaited<ReturnType<typeof getSupportedLanguagesI18nLanguagesGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSupportedLanguagesI18nLanguagesGet>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get supported languages
 */

export function useGetSupportedLanguagesI18nLanguagesGet<TData = Awaited<ReturnType<typeof getSupportedLanguagesI18nLanguagesGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSupportedLanguagesI18nLanguagesGet>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSupportedLanguagesI18nLanguagesGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get list of all timezones supported by the system
 * @summary Get supported timezones
 */
export type getTimezonesI18nTimezonesGetResponse200 = {
  data: SuccessResponseTimezonesData
  status: 200
}
    
export type getTimezonesI18nTimezonesGetResponseComposite = getTimezonesI18nTimezonesGetResponse200;
    
export type getTimezonesI18nTimezonesGetResponse = getTimezonesI18nTimezonesGetResponseComposite & {
  headers: Headers;
}

export const getGetTimezonesI18nTimezonesGetUrl = () => {


  

  return `/i18n/timezones`
}

export const getTimezonesI18nTimezonesGet = async ( options?: RequestInit): Promise<getTimezonesI18nTimezonesGetResponse> => {
  
  const res = await fetch(getGetTimezonesI18nTimezonesGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getTimezonesI18nTimezonesGetResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getTimezonesI18nTimezonesGetResponse
}



export const getGetTimezonesI18nTimezonesGetQueryKey = () => {
    return [`/i18n/timezones`] as const;
    }

    
export const getGetTimezonesI18nTimezonesGetQueryOptions = <TData = Awaited<ReturnType<typeof getTimezonesI18nTimezonesGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimezonesI18nTimezonesGet>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimezonesI18nTimezonesGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimezonesI18nTimezonesGet>>> = ({ signal }) => getTimezonesI18nTimezonesGet({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTimezonesI18nTimezonesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTimezonesI18nTimezonesGetQueryResult = NonNullable<Awaited<ReturnType<typeof getTimezonesI18nTimezonesGet>>>
export type GetTimezonesI18nTimezonesGetQueryError = unknown


export function useGetTimezonesI18nTimezonesGet<TData = Awaited<ReturnType<typeof getTimezonesI18nTimezonesGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimezonesI18nTimezonesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimezonesI18nTimezonesGet>>,
          TError,
          Awaited<ReturnType<typeof getTimezonesI18nTimezonesGet>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTimezonesI18nTimezonesGet<TData = Awaited<ReturnType<typeof getTimezonesI18nTimezonesGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimezonesI18nTimezonesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimezonesI18nTimezonesGet>>,
          TError,
          Awaited<ReturnType<typeof getTimezonesI18nTimezonesGet>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTimezonesI18nTimezonesGet<TData = Awaited<ReturnType<typeof getTimezonesI18nTimezonesGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimezonesI18nTimezonesGet>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get supported timezones
 */

export function useGetTimezonesI18nTimezonesGet<TData = Awaited<ReturnType<typeof getTimezonesI18nTimezonesGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimezonesI18nTimezonesGet>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTimezonesI18nTimezonesGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Set user's preferred language
 * @summary Set language
 */
export type setLanguageI18nLanguagePutResponse200 = {
  data: SuccessResponseUserI18nSettingsData
  status: 200
}

export type setLanguageI18nLanguagePutResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type setLanguageI18nLanguagePutResponseComposite = setLanguageI18nLanguagePutResponse200 | setLanguageI18nLanguagePutResponse422;
    
export type setLanguageI18nLanguagePutResponse = setLanguageI18nLanguagePutResponseComposite & {
  headers: Headers;
}

export const getSetLanguageI18nLanguagePutUrl = () => {


  

  return `/i18n/language`
}

export const setLanguageI18nLanguagePut = async (languageRequest: LanguageRequest, options?: RequestInit): Promise<setLanguageI18nLanguagePutResponse> => {
  
  const res = await fetch(getSetLanguageI18nLanguagePutUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      languageRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: setLanguageI18nLanguagePutResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as setLanguageI18nLanguagePutResponse
}




export const getSetLanguageI18nLanguagePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setLanguageI18nLanguagePut>>, TError,{data: LanguageRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof setLanguageI18nLanguagePut>>, TError,{data: LanguageRequest}, TContext> => {

const mutationKey = ['setLanguageI18nLanguagePut'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof setLanguageI18nLanguagePut>>, {data: LanguageRequest}> = (props) => {
          const {data} = props ?? {};

          return  setLanguageI18nLanguagePut(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SetLanguageI18nLanguagePutMutationResult = NonNullable<Awaited<ReturnType<typeof setLanguageI18nLanguagePut>>>
    export type SetLanguageI18nLanguagePutMutationBody = LanguageRequest
    export type SetLanguageI18nLanguagePutMutationError = HTTPValidationError

    /**
 * @summary Set language
 */
export const useSetLanguageI18nLanguagePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setLanguageI18nLanguagePut>>, TError,{data: LanguageRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof setLanguageI18nLanguagePut>>,
        TError,
        {data: LanguageRequest},
        TContext
      > => {

      const mutationOptions = getSetLanguageI18nLanguagePutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Set user's preferred timezone
 * @summary Set timezone
 */
export type setTimezoneI18nTimezonePutResponse200 = {
  data: SuccessResponseDict
  status: 200
}

export type setTimezoneI18nTimezonePutResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type setTimezoneI18nTimezonePutResponseComposite = setTimezoneI18nTimezonePutResponse200 | setTimezoneI18nTimezonePutResponse422;
    
export type setTimezoneI18nTimezonePutResponse = setTimezoneI18nTimezonePutResponseComposite & {
  headers: Headers;
}

export const getSetTimezoneI18nTimezonePutUrl = () => {


  

  return `/i18n/timezone`
}

export const setTimezoneI18nTimezonePut = async (timezoneRequest: TimezoneRequest, options?: RequestInit): Promise<setTimezoneI18nTimezonePutResponse> => {
  
  const res = await fetch(getSetTimezoneI18nTimezonePutUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      timezoneRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: setTimezoneI18nTimezonePutResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as setTimezoneI18nTimezonePutResponse
}




export const getSetTimezoneI18nTimezonePutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setTimezoneI18nTimezonePut>>, TError,{data: TimezoneRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof setTimezoneI18nTimezonePut>>, TError,{data: TimezoneRequest}, TContext> => {

const mutationKey = ['setTimezoneI18nTimezonePut'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof setTimezoneI18nTimezonePut>>, {data: TimezoneRequest}> = (props) => {
          const {data} = props ?? {};

          return  setTimezoneI18nTimezonePut(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SetTimezoneI18nTimezonePutMutationResult = NonNullable<Awaited<ReturnType<typeof setTimezoneI18nTimezonePut>>>
    export type SetTimezoneI18nTimezonePutMutationBody = TimezoneRequest
    export type SetTimezoneI18nTimezonePutMutationError = HTTPValidationError

    /**
 * @summary Set timezone
 */
export const useSetTimezoneI18nTimezonePut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setTimezoneI18nTimezonePut>>, TError,{data: TimezoneRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof setTimezoneI18nTimezonePut>>,
        TError,
        {data: TimezoneRequest},
        TContext
      > => {

      const mutationOptions = getSetTimezoneI18nTimezonePutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Detect user's preferred language based on Accept-Language header
 * @summary Detect language
 */
export type detectLanguageI18nDetectLanguagePostResponse200 = {
  data: SuccessResponseLanguageDetectionData
  status: 200
}

export type detectLanguageI18nDetectLanguagePostResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type detectLanguageI18nDetectLanguagePostResponseComposite = detectLanguageI18nDetectLanguagePostResponse200 | detectLanguageI18nDetectLanguagePostResponse422;
    
export type detectLanguageI18nDetectLanguagePostResponse = detectLanguageI18nDetectLanguagePostResponseComposite & {
  headers: Headers;
}

export const getDetectLanguageI18nDetectLanguagePostUrl = () => {


  

  return `/i18n/detect-language`
}

export const detectLanguageI18nDetectLanguagePost = async (languageDetectionRequest: LanguageDetectionRequest, options?: RequestInit): Promise<detectLanguageI18nDetectLanguagePostResponse> => {
  
  const res = await fetch(getDetectLanguageI18nDetectLanguagePostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      languageDetectionRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: detectLanguageI18nDetectLanguagePostResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as detectLanguageI18nDetectLanguagePostResponse
}




export const getDetectLanguageI18nDetectLanguagePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof detectLanguageI18nDetectLanguagePost>>, TError,{data: LanguageDetectionRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof detectLanguageI18nDetectLanguagePost>>, TError,{data: LanguageDetectionRequest}, TContext> => {

const mutationKey = ['detectLanguageI18nDetectLanguagePost'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof detectLanguageI18nDetectLanguagePost>>, {data: LanguageDetectionRequest}> = (props) => {
          const {data} = props ?? {};

          return  detectLanguageI18nDetectLanguagePost(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DetectLanguageI18nDetectLanguagePostMutationResult = NonNullable<Awaited<ReturnType<typeof detectLanguageI18nDetectLanguagePost>>>
    export type DetectLanguageI18nDetectLanguagePostMutationBody = LanguageDetectionRequest
    export type DetectLanguageI18nDetectLanguagePostMutationError = HTTPValidationError

    /**
 * @summary Detect language
 */
export const useDetectLanguageI18nDetectLanguagePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof detectLanguageI18nDetectLanguagePost>>, TError,{data: LanguageDetectionRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof detectLanguageI18nDetectLanguagePost>>,
        TError,
        {data: LanguageDetectionRequest},
        TContext
      > => {

      const mutationOptions = getDetectLanguageI18nDetectLanguagePostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get translated text based on specified key and language
 * @summary Translate text
 */
export type translateI18nTranslatePostResponse200 = {
  data: SuccessResponseTranslationData
  status: 200
}

export type translateI18nTranslatePostResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type translateI18nTranslatePostResponseComposite = translateI18nTranslatePostResponse200 | translateI18nTranslatePostResponse422;
    
export type translateI18nTranslatePostResponse = translateI18nTranslatePostResponseComposite & {
  headers: Headers;
}

export const getTranslateI18nTranslatePostUrl = () => {


  

  return `/i18n/translate`
}

export const translateI18nTranslatePost = async (translationRequest: TranslationRequest, options?: RequestInit): Promise<translateI18nTranslatePostResponse> => {
  
  const res = await fetch(getTranslateI18nTranslatePostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      translationRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: translateI18nTranslatePostResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as translateI18nTranslatePostResponse
}




export const getTranslateI18nTranslatePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof translateI18nTranslatePost>>, TError,{data: TranslationRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof translateI18nTranslatePost>>, TError,{data: TranslationRequest}, TContext> => {

const mutationKey = ['translateI18nTranslatePost'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof translateI18nTranslatePost>>, {data: TranslationRequest}> = (props) => {
          const {data} = props ?? {};

          return  translateI18nTranslatePost(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TranslateI18nTranslatePostMutationResult = NonNullable<Awaited<ReturnType<typeof translateI18nTranslatePost>>>
    export type TranslateI18nTranslatePostMutationBody = TranslationRequest
    export type TranslateI18nTranslatePostMutationError = HTTPValidationError

    /**
 * @summary Translate text
 */
export const useTranslateI18nTranslatePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof translateI18nTranslatePost>>, TError,{data: TranslationRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof translateI18nTranslatePost>>,
        TError,
        {data: TranslationRequest},
        TContext
      > => {

      const mutationOptions = getTranslateI18nTranslatePostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Format datetime according to user's localization settings
 * @summary Format datetime
 */
export type formatDatetimeI18nFormatDatetimePostResponse200 = {
  data: SuccessResponseDateTimeFormatData
  status: 200
}

export type formatDatetimeI18nFormatDatetimePostResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type formatDatetimeI18nFormatDatetimePostResponseComposite = formatDatetimeI18nFormatDatetimePostResponse200 | formatDatetimeI18nFormatDatetimePostResponse422;
    
export type formatDatetimeI18nFormatDatetimePostResponse = formatDatetimeI18nFormatDatetimePostResponseComposite & {
  headers: Headers;
}

export const getFormatDatetimeI18nFormatDatetimePostUrl = () => {


  

  return `/i18n/format/datetime`
}

export const formatDatetimeI18nFormatDatetimePost = async (dateTimeFormatRequest: DateTimeFormatRequest, options?: RequestInit): Promise<formatDatetimeI18nFormatDatetimePostResponse> => {
  
  const res = await fetch(getFormatDatetimeI18nFormatDatetimePostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      dateTimeFormatRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: formatDatetimeI18nFormatDatetimePostResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as formatDatetimeI18nFormatDatetimePostResponse
}




export const getFormatDatetimeI18nFormatDatetimePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof formatDatetimeI18nFormatDatetimePost>>, TError,{data: DateTimeFormatRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof formatDatetimeI18nFormatDatetimePost>>, TError,{data: DateTimeFormatRequest}, TContext> => {

const mutationKey = ['formatDatetimeI18nFormatDatetimePost'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof formatDatetimeI18nFormatDatetimePost>>, {data: DateTimeFormatRequest}> = (props) => {
          const {data} = props ?? {};

          return  formatDatetimeI18nFormatDatetimePost(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FormatDatetimeI18nFormatDatetimePostMutationResult = NonNullable<Awaited<ReturnType<typeof formatDatetimeI18nFormatDatetimePost>>>
    export type FormatDatetimeI18nFormatDatetimePostMutationBody = DateTimeFormatRequest
    export type FormatDatetimeI18nFormatDatetimePostMutationError = HTTPValidationError

    /**
 * @summary Format datetime
 */
export const useFormatDatetimeI18nFormatDatetimePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof formatDatetimeI18nFormatDatetimePost>>, TError,{data: DateTimeFormatRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof formatDatetimeI18nFormatDatetimePost>>,
        TError,
        {data: DateTimeFormatRequest},
        TContext
      > => {

      const mutationOptions = getFormatDatetimeI18nFormatDatetimePostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Format number according to user's localization settings
 * @summary Format number
 */
export type formatNumberI18nFormatNumberPostResponse200 = {
  data: SuccessResponseNumberFormatData
  status: 200
}

export type formatNumberI18nFormatNumberPostResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type formatNumberI18nFormatNumberPostResponseComposite = formatNumberI18nFormatNumberPostResponse200 | formatNumberI18nFormatNumberPostResponse422;
    
export type formatNumberI18nFormatNumberPostResponse = formatNumberI18nFormatNumberPostResponseComposite & {
  headers: Headers;
}

export const getFormatNumberI18nFormatNumberPostUrl = () => {


  

  return `/i18n/format/number`
}

export const formatNumberI18nFormatNumberPost = async (numberFormatRequest: NumberFormatRequest, options?: RequestInit): Promise<formatNumberI18nFormatNumberPostResponse> => {
  
  const res = await fetch(getFormatNumberI18nFormatNumberPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      numberFormatRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: formatNumberI18nFormatNumberPostResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as formatNumberI18nFormatNumberPostResponse
}




export const getFormatNumberI18nFormatNumberPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof formatNumberI18nFormatNumberPost>>, TError,{data: NumberFormatRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof formatNumberI18nFormatNumberPost>>, TError,{data: NumberFormatRequest}, TContext> => {

const mutationKey = ['formatNumberI18nFormatNumberPost'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof formatNumberI18nFormatNumberPost>>, {data: NumberFormatRequest}> = (props) => {
          const {data} = props ?? {};

          return  formatNumberI18nFormatNumberPost(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FormatNumberI18nFormatNumberPostMutationResult = NonNullable<Awaited<ReturnType<typeof formatNumberI18nFormatNumberPost>>>
    export type FormatNumberI18nFormatNumberPostMutationBody = NumberFormatRequest
    export type FormatNumberI18nFormatNumberPostMutationError = HTTPValidationError

    /**
 * @summary Format number
 */
export const useFormatNumberI18nFormatNumberPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof formatNumberI18nFormatNumberPost>>, TError,{data: NumberFormatRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof formatNumberI18nFormatNumberPost>>,
        TError,
        {data: NumberFormatRequest},
        TContext
      > => {

      const mutationOptions = getFormatNumberI18nFormatNumberPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Format currency amount according to user's localization settings
 * @summary Format currency
 */
export type formatCurrencyI18nFormatCurrencyPostResponse200 = {
  data: SuccessResponseCurrencyFormatData
  status: 200
}

export type formatCurrencyI18nFormatCurrencyPostResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type formatCurrencyI18nFormatCurrencyPostResponseComposite = formatCurrencyI18nFormatCurrencyPostResponse200 | formatCurrencyI18nFormatCurrencyPostResponse422;
    
export type formatCurrencyI18nFormatCurrencyPostResponse = formatCurrencyI18nFormatCurrencyPostResponseComposite & {
  headers: Headers;
}

export const getFormatCurrencyI18nFormatCurrencyPostUrl = () => {


  

  return `/i18n/format/currency`
}

export const formatCurrencyI18nFormatCurrencyPost = async (currencyFormatRequest: CurrencyFormatRequest, options?: RequestInit): Promise<formatCurrencyI18nFormatCurrencyPostResponse> => {
  
  const res = await fetch(getFormatCurrencyI18nFormatCurrencyPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      currencyFormatRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: formatCurrencyI18nFormatCurrencyPostResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as formatCurrencyI18nFormatCurrencyPostResponse
}




export const getFormatCurrencyI18nFormatCurrencyPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof formatCurrencyI18nFormatCurrencyPost>>, TError,{data: CurrencyFormatRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof formatCurrencyI18nFormatCurrencyPost>>, TError,{data: CurrencyFormatRequest}, TContext> => {

const mutationKey = ['formatCurrencyI18nFormatCurrencyPost'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof formatCurrencyI18nFormatCurrencyPost>>, {data: CurrencyFormatRequest}> = (props) => {
          const {data} = props ?? {};

          return  formatCurrencyI18nFormatCurrencyPost(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FormatCurrencyI18nFormatCurrencyPostMutationResult = NonNullable<Awaited<ReturnType<typeof formatCurrencyI18nFormatCurrencyPost>>>
    export type FormatCurrencyI18nFormatCurrencyPostMutationBody = CurrencyFormatRequest
    export type FormatCurrencyI18nFormatCurrencyPostMutationError = HTTPValidationError

    /**
 * @summary Format currency
 */
export const useFormatCurrencyI18nFormatCurrencyPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof formatCurrencyI18nFormatCurrencyPost>>, TError,{data: CurrencyFormatRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof formatCurrencyI18nFormatCurrencyPost>>,
        TError,
        {data: CurrencyFormatRequest},
        TContext
      > => {

      const mutationOptions = getFormatCurrencyI18nFormatCurrencyPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get internationalization settings for specified user
 * @summary Get user i18n settings
 */
export type getUserSettingsI18nUserSettingsGetResponse200 = {
  data: SuccessResponseUserI18nSettingsData
  status: 200
}

export type getUserSettingsI18nUserSettingsGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getUserSettingsI18nUserSettingsGetResponseComposite = getUserSettingsI18nUserSettingsGetResponse200 | getUserSettingsI18nUserSettingsGetResponse422;
    
export type getUserSettingsI18nUserSettingsGetResponse = getUserSettingsI18nUserSettingsGetResponseComposite & {
  headers: Headers;
}

export const getGetUserSettingsI18nUserSettingsGetUrl = () => {


  

  return `/i18n/user/settings`
}

export const getUserSettingsI18nUserSettingsGet = async ( options?: RequestInit): Promise<getUserSettingsI18nUserSettingsGetResponse> => {
  
  const res = await fetch(getGetUserSettingsI18nUserSettingsGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getUserSettingsI18nUserSettingsGetResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getUserSettingsI18nUserSettingsGetResponse
}



export const getGetUserSettingsI18nUserSettingsGetQueryKey = () => {
    return [`/i18n/user/settings`] as const;
    }

    
export const getGetUserSettingsI18nUserSettingsGetQueryOptions = <TData = Awaited<ReturnType<typeof getUserSettingsI18nUserSettingsGet>>, TError = HTTPValidationError>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserSettingsI18nUserSettingsGet>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserSettingsI18nUserSettingsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserSettingsI18nUserSettingsGet>>> = ({ signal }) => getUserSettingsI18nUserSettingsGet({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserSettingsI18nUserSettingsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserSettingsI18nUserSettingsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUserSettingsI18nUserSettingsGet>>>
export type GetUserSettingsI18nUserSettingsGetQueryError = HTTPValidationError


export function useGetUserSettingsI18nUserSettingsGet<TData = Awaited<ReturnType<typeof getUserSettingsI18nUserSettingsGet>>, TError = HTTPValidationError>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserSettingsI18nUserSettingsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserSettingsI18nUserSettingsGet>>,
          TError,
          Awaited<ReturnType<typeof getUserSettingsI18nUserSettingsGet>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserSettingsI18nUserSettingsGet<TData = Awaited<ReturnType<typeof getUserSettingsI18nUserSettingsGet>>, TError = HTTPValidationError>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserSettingsI18nUserSettingsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserSettingsI18nUserSettingsGet>>,
          TError,
          Awaited<ReturnType<typeof getUserSettingsI18nUserSettingsGet>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserSettingsI18nUserSettingsGet<TData = Awaited<ReturnType<typeof getUserSettingsI18nUserSettingsGet>>, TError = HTTPValidationError>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserSettingsI18nUserSettingsGet>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get user i18n settings
 */

export function useGetUserSettingsI18nUserSettingsGet<TData = Awaited<ReturnType<typeof getUserSettingsI18nUserSettingsGet>>, TError = HTTPValidationError>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserSettingsI18nUserSettingsGet>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserSettingsI18nUserSettingsGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update internationalization settings for specified user
 * @summary Update user i18n settings
 */
export type updateUserSettingsI18nUserSettingsPutResponse200 = {
  data: SuccessResponseUserI18nSettingsData
  status: 200
}

export type updateUserSettingsI18nUserSettingsPutResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type updateUserSettingsI18nUserSettingsPutResponseComposite = updateUserSettingsI18nUserSettingsPutResponse200 | updateUserSettingsI18nUserSettingsPutResponse422;
    
export type updateUserSettingsI18nUserSettingsPutResponse = updateUserSettingsI18nUserSettingsPutResponseComposite & {
  headers: Headers;
}

export const getUpdateUserSettingsI18nUserSettingsPutUrl = () => {


  

  return `/i18n/user/settings`
}

export const updateUserSettingsI18nUserSettingsPut = async (userI18nSettingsRequest: UserI18nSettingsRequest, options?: RequestInit): Promise<updateUserSettingsI18nUserSettingsPutResponse> => {
  
  const res = await fetch(getUpdateUserSettingsI18nUserSettingsPutUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userI18nSettingsRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: updateUserSettingsI18nUserSettingsPutResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as updateUserSettingsI18nUserSettingsPutResponse
}




export const getUpdateUserSettingsI18nUserSettingsPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserSettingsI18nUserSettingsPut>>, TError,{data: UserI18nSettingsRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateUserSettingsI18nUserSettingsPut>>, TError,{data: UserI18nSettingsRequest}, TContext> => {

const mutationKey = ['updateUserSettingsI18nUserSettingsPut'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUserSettingsI18nUserSettingsPut>>, {data: UserI18nSettingsRequest}> = (props) => {
          const {data} = props ?? {};

          return  updateUserSettingsI18nUserSettingsPut(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserSettingsI18nUserSettingsPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateUserSettingsI18nUserSettingsPut>>>
    export type UpdateUserSettingsI18nUserSettingsPutMutationBody = UserI18nSettingsRequest
    export type UpdateUserSettingsI18nUserSettingsPutMutationError = HTTPValidationError

    /**
 * @summary Update user i18n settings
 */
export const useUpdateUserSettingsI18nUserSettingsPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserSettingsI18nUserSettingsPut>>, TError,{data: UserI18nSettingsRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateUserSettingsI18nUserSettingsPut>>,
        TError,
        {data: UserI18nSettingsRequest},
        TContext
      > => {

      const mutationOptions = getUpdateUserSettingsI18nUserSettingsPutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Get i18n context information for inter-agent communication
 * @summary Get Agent i18n context
 */
export type getAgentContextI18nAgentContextGetResponse200 = {
  data: SuccessResponseAgentI18nContextData
  status: 200
}

export type getAgentContextI18nAgentContextGetResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type getAgentContextI18nAgentContextGetResponseComposite = getAgentContextI18nAgentContextGetResponse200 | getAgentContextI18nAgentContextGetResponse422;
    
export type getAgentContextI18nAgentContextGetResponse = getAgentContextI18nAgentContextGetResponseComposite & {
  headers: Headers;
}

export const getGetAgentContextI18nAgentContextGetUrl = () => {


  

  return `/i18n/agent/context`
}

export const getAgentContextI18nAgentContextGet = async ( options?: RequestInit): Promise<getAgentContextI18nAgentContextGetResponse> => {
  
  const res = await fetch(getGetAgentContextI18nAgentContextGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getAgentContextI18nAgentContextGetResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getAgentContextI18nAgentContextGetResponse
}



export const getGetAgentContextI18nAgentContextGetQueryKey = () => {
    return [`/i18n/agent/context`] as const;
    }

    
export const getGetAgentContextI18nAgentContextGetQueryOptions = <TData = Awaited<ReturnType<typeof getAgentContextI18nAgentContextGet>>, TError = HTTPValidationError>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgentContextI18nAgentContextGet>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAgentContextI18nAgentContextGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAgentContextI18nAgentContextGet>>> = ({ signal }) => getAgentContextI18nAgentContextGet({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAgentContextI18nAgentContextGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAgentContextI18nAgentContextGetQueryResult = NonNullable<Awaited<ReturnType<typeof getAgentContextI18nAgentContextGet>>>
export type GetAgentContextI18nAgentContextGetQueryError = HTTPValidationError


export function useGetAgentContextI18nAgentContextGet<TData = Awaited<ReturnType<typeof getAgentContextI18nAgentContextGet>>, TError = HTTPValidationError>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgentContextI18nAgentContextGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAgentContextI18nAgentContextGet>>,
          TError,
          Awaited<ReturnType<typeof getAgentContextI18nAgentContextGet>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAgentContextI18nAgentContextGet<TData = Awaited<ReturnType<typeof getAgentContextI18nAgentContextGet>>, TError = HTTPValidationError>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgentContextI18nAgentContextGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAgentContextI18nAgentContextGet>>,
          TError,
          Awaited<ReturnType<typeof getAgentContextI18nAgentContextGet>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAgentContextI18nAgentContextGet<TData = Awaited<ReturnType<typeof getAgentContextI18nAgentContextGet>>, TError = HTTPValidationError>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgentContextI18nAgentContextGet>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Agent i18n context
 */

export function useGetAgentContextI18nAgentContextGet<TData = Awaited<ReturnType<typeof getAgentContextI18nAgentContextGet>>, TError = HTTPValidationError>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAgentContextI18nAgentContextGet>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAgentContextI18nAgentContextGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get ValueCell application basic information including name, version and environment
 * @summary Get application info
 */
export type getAppInfoApiV1SystemInfoGetResponse200 = {
  data: SuccessResponseAppInfoData
  status: 200
}
    
export type getAppInfoApiV1SystemInfoGetResponseComposite = getAppInfoApiV1SystemInfoGetResponse200;
    
export type getAppInfoApiV1SystemInfoGetResponse = getAppInfoApiV1SystemInfoGetResponseComposite & {
  headers: Headers;
}

export const getGetAppInfoApiV1SystemInfoGetUrl = () => {


  

  return `/api/v1/system/info`
}

export const getAppInfoApiV1SystemInfoGet = async ( options?: RequestInit): Promise<getAppInfoApiV1SystemInfoGetResponse> => {
  
  const res = await fetch(getGetAppInfoApiV1SystemInfoGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getAppInfoApiV1SystemInfoGetResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getAppInfoApiV1SystemInfoGetResponse
}



export const getGetAppInfoApiV1SystemInfoGetQueryKey = () => {
    return [`/api/v1/system/info`] as const;
    }

    
export const getGetAppInfoApiV1SystemInfoGetQueryOptions = <TData = Awaited<ReturnType<typeof getAppInfoApiV1SystemInfoGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppInfoApiV1SystemInfoGet>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAppInfoApiV1SystemInfoGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAppInfoApiV1SystemInfoGet>>> = ({ signal }) => getAppInfoApiV1SystemInfoGet({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAppInfoApiV1SystemInfoGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAppInfoApiV1SystemInfoGetQueryResult = NonNullable<Awaited<ReturnType<typeof getAppInfoApiV1SystemInfoGet>>>
export type GetAppInfoApiV1SystemInfoGetQueryError = unknown


export function useGetAppInfoApiV1SystemInfoGet<TData = Awaited<ReturnType<typeof getAppInfoApiV1SystemInfoGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppInfoApiV1SystemInfoGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppInfoApiV1SystemInfoGet>>,
          TError,
          Awaited<ReturnType<typeof getAppInfoApiV1SystemInfoGet>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAppInfoApiV1SystemInfoGet<TData = Awaited<ReturnType<typeof getAppInfoApiV1SystemInfoGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppInfoApiV1SystemInfoGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppInfoApiV1SystemInfoGet>>,
          TError,
          Awaited<ReturnType<typeof getAppInfoApiV1SystemInfoGet>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAppInfoApiV1SystemInfoGet<TData = Awaited<ReturnType<typeof getAppInfoApiV1SystemInfoGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppInfoApiV1SystemInfoGet>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get application info
 */

export function useGetAppInfoApiV1SystemInfoGet<TData = Awaited<ReturnType<typeof getAppInfoApiV1SystemInfoGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppInfoApiV1SystemInfoGet>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAppInfoApiV1SystemInfoGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Check service running status and version information
 * @summary Health check
 */
export type healthCheckApiV1SystemHealthGetResponse200 = {
  data: SuccessResponseHealthCheckData
  status: 200
}
    
export type healthCheckApiV1SystemHealthGetResponseComposite = healthCheckApiV1SystemHealthGetResponse200;
    
export type healthCheckApiV1SystemHealthGetResponse = healthCheckApiV1SystemHealthGetResponseComposite & {
  headers: Headers;
}

export const getHealthCheckApiV1SystemHealthGetUrl = () => {


  

  return `/api/v1/system/health`
}

export const healthCheckApiV1SystemHealthGet = async ( options?: RequestInit): Promise<healthCheckApiV1SystemHealthGetResponse> => {
  
  const res = await fetch(getHealthCheckApiV1SystemHealthGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: healthCheckApiV1SystemHealthGetResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as healthCheckApiV1SystemHealthGetResponse
}



export const getHealthCheckApiV1SystemHealthGetQueryKey = () => {
    return [`/api/v1/system/health`] as const;
    }

    
export const getHealthCheckApiV1SystemHealthGetQueryOptions = <TData = Awaited<ReturnType<typeof healthCheckApiV1SystemHealthGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckApiV1SystemHealthGet>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthCheckApiV1SystemHealthGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheckApiV1SystemHealthGet>>> = ({ signal }) => healthCheckApiV1SystemHealthGet({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof healthCheckApiV1SystemHealthGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthCheckApiV1SystemHealthGetQueryResult = NonNullable<Awaited<ReturnType<typeof healthCheckApiV1SystemHealthGet>>>
export type HealthCheckApiV1SystemHealthGetQueryError = unknown


export function useHealthCheckApiV1SystemHealthGet<TData = Awaited<ReturnType<typeof healthCheckApiV1SystemHealthGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckApiV1SystemHealthGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckApiV1SystemHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckApiV1SystemHealthGet>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheckApiV1SystemHealthGet<TData = Awaited<ReturnType<typeof healthCheckApiV1SystemHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckApiV1SystemHealthGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckApiV1SystemHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckApiV1SystemHealthGet>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheckApiV1SystemHealthGet<TData = Awaited<ReturnType<typeof healthCheckApiV1SystemHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckApiV1SystemHealthGet>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Health check
 */

export function useHealthCheckApiV1SystemHealthGet<TData = Awaited<ReturnType<typeof healthCheckApiV1SystemHealthGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheckApiV1SystemHealthGet>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHealthCheckApiV1SystemHealthGetQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const getRootGetResponseMock = (overrideResponse: Partial< SuccessResponseAppInfoData > = {}): SuccessResponseAppInfoData => ({code: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), msg: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), data: faker.helpers.arrayElement([faker.helpers.arrayElement([{name: faker.string.alpha({length: {min: 10, max: 20}}), version: faker.string.alpha({length: {min: 10, max: 20}}), environment: faker.string.alpha({length: {min: 10, max: 20}})},null,]), undefined]), ...overrideResponse})

export const getGetConfigI18nConfigGetResponseMock = (overrideResponse: Partial< SuccessResponseI18nConfigData > = {}): SuccessResponseI18nConfigData => ({code: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), msg: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), data: faker.helpers.arrayElement([faker.helpers.arrayElement([{language: faker.string.alpha({length: {min: 10, max: 20}}), timezone: faker.string.alpha({length: {min: 10, max: 20}}), date_format: faker.string.alpha({length: {min: 10, max: 20}}), time_format: faker.string.alpha({length: {min: 10, max: 20}}), datetime_format: faker.string.alpha({length: {min: 10, max: 20}}), currency_symbol: faker.string.alpha({length: {min: 10, max: 20}}), number_format: {
        [faker.string.alphanumeric(5)]: faker.string.alpha({length: {min: 10, max: 20}})
      }, is_rtl: faker.datatype.boolean()},null,]), undefined]), ...overrideResponse})

export const getGetSupportedLanguagesI18nLanguagesGetResponseMock = (overrideResponse: Partial< SuccessResponseSupportedLanguagesData > = {}): SuccessResponseSupportedLanguagesData => ({code: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), msg: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), data: faker.helpers.arrayElement([faker.helpers.arrayElement([{languages: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({code: faker.string.alpha({length: {min: 10, max: 20}}), name: faker.string.alpha({length: {min: 10, max: 20}}), is_current: faker.datatype.boolean()})), current: faker.string.alpha({length: {min: 10, max: 20}})},null,]), undefined]), ...overrideResponse})

export const getGetTimezonesI18nTimezonesGetResponseMock = (overrideResponse: Partial< SuccessResponseTimezonesData > = {}): SuccessResponseTimezonesData => ({code: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), msg: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), data: faker.helpers.arrayElement([faker.helpers.arrayElement([{timezones: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({value: faker.string.alpha({length: {min: 10, max: 20}}), label: faker.string.alpha({length: {min: 10, max: 20}}), is_current: faker.datatype.boolean()})), current: faker.string.alpha({length: {min: 10, max: 20}})},null,]), undefined]), ...overrideResponse})

export const getSetLanguageI18nLanguagePutResponseMock = (overrideResponse: Partial< SuccessResponseUserI18nSettingsData > = {}): SuccessResponseUserI18nSettingsData => ({code: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), msg: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), data: faker.helpers.arrayElement([faker.helpers.arrayElement([{user_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}),null,]), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), timezone: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), created_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`,null,]), undefined]), updated_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`,null,]), undefined])},null,]), undefined]), ...overrideResponse})

export const getSetTimezoneI18nTimezonePutResponseMock = (overrideResponse: Partial< SuccessResponseDict > = {}): SuccessResponseDict => ({code: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), msg: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), data: faker.helpers.arrayElement([faker.helpers.arrayElement([null,]), undefined]), ...overrideResponse})

export const getDetectLanguageI18nDetectLanguagePostResponseMock = (overrideResponse: Partial< SuccessResponseLanguageDetectionData > = {}): SuccessResponseLanguageDetectionData => ({code: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), msg: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), data: faker.helpers.arrayElement([faker.helpers.arrayElement([{detected_language: faker.string.alpha({length: {min: 10, max: 20}}), language_name: faker.string.alpha({length: {min: 10, max: 20}}), is_supported: faker.datatype.boolean()},null,]), undefined]), ...overrideResponse})

export const getTranslateI18nTranslatePostResponseMock = (overrideResponse: Partial< SuccessResponseTranslationData > = {}): SuccessResponseTranslationData => ({code: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), msg: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), data: faker.helpers.arrayElement([faker.helpers.arrayElement([{key: faker.string.alpha({length: {min: 10, max: 20}}), translated_text: faker.string.alpha({length: {min: 10, max: 20}}), language: faker.string.alpha({length: {min: 10, max: 20}}), variables: faker.helpers.arrayElement([{}, undefined])},null,]), undefined]), ...overrideResponse})

export const getFormatDatetimeI18nFormatDatetimePostResponseMock = (overrideResponse: Partial< SuccessResponseDateTimeFormatData > = {}): SuccessResponseDateTimeFormatData => ({code: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), msg: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), data: faker.helpers.arrayElement([faker.helpers.arrayElement([{original: faker.string.alpha({length: {min: 10, max: 20}}), formatted: faker.string.alpha({length: {min: 10, max: 20}}), format_type: faker.string.alpha({length: {min: 10, max: 20}}), language: faker.string.alpha({length: {min: 10, max: 20}}), timezone: faker.string.alpha({length: {min: 10, max: 20}})},null,]), undefined]), ...overrideResponse})

export const getFormatNumberI18nFormatNumberPostResponseMock = (overrideResponse: Partial< SuccessResponseNumberFormatData > = {}): SuccessResponseNumberFormatData => ({code: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), msg: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), data: faker.helpers.arrayElement([faker.helpers.arrayElement([{original: faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), formatted: faker.string.alpha({length: {min: 10, max: 20}}), decimal_places: faker.number.int({min: undefined, max: undefined}), language: faker.string.alpha({length: {min: 10, max: 20}})},null,]), undefined]), ...overrideResponse})

export const getFormatCurrencyI18nFormatCurrencyPostResponseMock = (overrideResponse: Partial< SuccessResponseCurrencyFormatData > = {}): SuccessResponseCurrencyFormatData => ({code: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), msg: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), data: faker.helpers.arrayElement([faker.helpers.arrayElement([{original: faker.number.float({min: undefined, max: undefined, fractionDigits: 2}), formatted: faker.string.alpha({length: {min: 10, max: 20}}), decimal_places: faker.number.int({min: undefined, max: undefined}), language: faker.string.alpha({length: {min: 10, max: 20}}), currency_symbol: faker.string.alpha({length: {min: 10, max: 20}})},null,]), undefined]), ...overrideResponse})

export const getGetUserSettingsI18nUserSettingsGetResponseMock = (overrideResponse: Partial< SuccessResponseUserI18nSettingsData > = {}): SuccessResponseUserI18nSettingsData => ({code: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), msg: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), data: faker.helpers.arrayElement([faker.helpers.arrayElement([{user_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}),null,]), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), timezone: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), created_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`,null,]), undefined]), updated_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`,null,]), undefined])},null,]), undefined]), ...overrideResponse})

export const getUpdateUserSettingsI18nUserSettingsPutResponseMock = (overrideResponse: Partial< SuccessResponseUserI18nSettingsData > = {}): SuccessResponseUserI18nSettingsData => ({code: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), msg: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), data: faker.helpers.arrayElement([faker.helpers.arrayElement([{user_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}),null,]), undefined]), language: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), timezone: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), created_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`,null,]), undefined]), updated_at: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`,null,]), undefined])},null,]), undefined]), ...overrideResponse})

export const getGetAgentContextI18nAgentContextGetResponseMock = (overrideResponse: Partial< SuccessResponseAgentI18nContextData > = {}): SuccessResponseAgentI18nContextData => ({code: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), msg: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), data: faker.helpers.arrayElement([faker.helpers.arrayElement([{language: faker.string.alpha({length: {min: 10, max: 20}}), timezone: faker.string.alpha({length: {min: 10, max: 20}}), currency_symbol: faker.string.alpha({length: {min: 10, max: 20}}), date_format: faker.string.alpha({length: {min: 10, max: 20}}), time_format: faker.string.alpha({length: {min: 10, max: 20}}), number_format: {
        [faker.string.alphanumeric(5)]: faker.string.alpha({length: {min: 10, max: 20}})
      }, user_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}),null,]), undefined]), session_id: faker.helpers.arrayElement([faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}),null,]), undefined])},null,]), undefined]), ...overrideResponse})

export const getGetAppInfoApiV1SystemInfoGetResponseMock = (overrideResponse: Partial< SuccessResponseAppInfoData > = {}): SuccessResponseAppInfoData => ({code: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), msg: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), data: faker.helpers.arrayElement([faker.helpers.arrayElement([{name: faker.string.alpha({length: {min: 10, max: 20}}), version: faker.string.alpha({length: {min: 10, max: 20}}), environment: faker.string.alpha({length: {min: 10, max: 20}})},null,]), undefined]), ...overrideResponse})

export const getHealthCheckApiV1SystemHealthGetResponseMock = (overrideResponse: Partial< SuccessResponseHealthCheckData > = {}): SuccessResponseHealthCheckData => ({code: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), msg: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), data: faker.helpers.arrayElement([faker.helpers.arrayElement([{status: faker.string.alpha({length: {min: 10, max: 20}}), version: faker.string.alpha({length: {min: 10, max: 20}}), timestamp: faker.helpers.arrayElement([faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`,null,]), undefined])},null,]), undefined]), ...overrideResponse})


export const getRootGetMockHandler = (overrideResponse?: SuccessResponseAppInfoData | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<SuccessResponseAppInfoData> | SuccessResponseAppInfoData)) => {
  return http.get('*/', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getRootGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetConfigI18nConfigGetMockHandler = (overrideResponse?: SuccessResponseI18nConfigData | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<SuccessResponseI18nConfigData> | SuccessResponseI18nConfigData)) => {
  return http.get('*/i18n/config', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetConfigI18nConfigGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetSupportedLanguagesI18nLanguagesGetMockHandler = (overrideResponse?: SuccessResponseSupportedLanguagesData | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<SuccessResponseSupportedLanguagesData> | SuccessResponseSupportedLanguagesData)) => {
  return http.get('*/i18n/languages', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetSupportedLanguagesI18nLanguagesGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetTimezonesI18nTimezonesGetMockHandler = (overrideResponse?: SuccessResponseTimezonesData | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<SuccessResponseTimezonesData> | SuccessResponseTimezonesData)) => {
  return http.get('*/i18n/timezones', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetTimezonesI18nTimezonesGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getSetLanguageI18nLanguagePutMockHandler = (overrideResponse?: SuccessResponseUserI18nSettingsData | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<SuccessResponseUserI18nSettingsData> | SuccessResponseUserI18nSettingsData)) => {
  return http.put('*/i18n/language', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getSetLanguageI18nLanguagePutResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getSetTimezoneI18nTimezonePutMockHandler = (overrideResponse?: SuccessResponseDict | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<SuccessResponseDict> | SuccessResponseDict)) => {
  return http.put('*/i18n/timezone', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getSetTimezoneI18nTimezonePutResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getDetectLanguageI18nDetectLanguagePostMockHandler = (overrideResponse?: SuccessResponseLanguageDetectionData | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SuccessResponseLanguageDetectionData> | SuccessResponseLanguageDetectionData)) => {
  return http.post('*/i18n/detect-language', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getDetectLanguageI18nDetectLanguagePostResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getTranslateI18nTranslatePostMockHandler = (overrideResponse?: SuccessResponseTranslationData | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SuccessResponseTranslationData> | SuccessResponseTranslationData)) => {
  return http.post('*/i18n/translate', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getTranslateI18nTranslatePostResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getFormatDatetimeI18nFormatDatetimePostMockHandler = (overrideResponse?: SuccessResponseDateTimeFormatData | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SuccessResponseDateTimeFormatData> | SuccessResponseDateTimeFormatData)) => {
  return http.post('*/i18n/format/datetime', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getFormatDatetimeI18nFormatDatetimePostResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getFormatNumberI18nFormatNumberPostMockHandler = (overrideResponse?: SuccessResponseNumberFormatData | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SuccessResponseNumberFormatData> | SuccessResponseNumberFormatData)) => {
  return http.post('*/i18n/format/number', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getFormatNumberI18nFormatNumberPostResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getFormatCurrencyI18nFormatCurrencyPostMockHandler = (overrideResponse?: SuccessResponseCurrencyFormatData | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<SuccessResponseCurrencyFormatData> | SuccessResponseCurrencyFormatData)) => {
  return http.post('*/i18n/format/currency', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getFormatCurrencyI18nFormatCurrencyPostResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetUserSettingsI18nUserSettingsGetMockHandler = (overrideResponse?: SuccessResponseUserI18nSettingsData | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<SuccessResponseUserI18nSettingsData> | SuccessResponseUserI18nSettingsData)) => {
  return http.get('*/i18n/user/settings', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetUserSettingsI18nUserSettingsGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getUpdateUserSettingsI18nUserSettingsPutMockHandler = (overrideResponse?: SuccessResponseUserI18nSettingsData | ((info: Parameters<Parameters<typeof http.put>[1]>[0]) => Promise<SuccessResponseUserI18nSettingsData> | SuccessResponseUserI18nSettingsData)) => {
  return http.put('*/i18n/user/settings', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getUpdateUserSettingsI18nUserSettingsPutResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetAgentContextI18nAgentContextGetMockHandler = (overrideResponse?: SuccessResponseAgentI18nContextData | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<SuccessResponseAgentI18nContextData> | SuccessResponseAgentI18nContextData)) => {
  return http.get('*/i18n/agent/context', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetAgentContextI18nAgentContextGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetAppInfoApiV1SystemInfoGetMockHandler = (overrideResponse?: SuccessResponseAppInfoData | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<SuccessResponseAppInfoData> | SuccessResponseAppInfoData)) => {
  return http.get('*/api/v1/system/info', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetAppInfoApiV1SystemInfoGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getHealthCheckApiV1SystemHealthGetMockHandler = (overrideResponse?: SuccessResponseHealthCheckData | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<SuccessResponseHealthCheckData> | SuccessResponseHealthCheckData)) => {
  return http.get('*/api/v1/system/health', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getHealthCheckApiV1SystemHealthGetResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}
export const getValueCellServerAPIMock = () => [
  getRootGetMockHandler(),
  getGetConfigI18nConfigGetMockHandler(),
  getGetSupportedLanguagesI18nLanguagesGetMockHandler(),
  getGetTimezonesI18nTimezonesGetMockHandler(),
  getSetLanguageI18nLanguagePutMockHandler(),
  getSetTimezoneI18nTimezonePutMockHandler(),
  getDetectLanguageI18nDetectLanguagePostMockHandler(),
  getTranslateI18nTranslatePostMockHandler(),
  getFormatDatetimeI18nFormatDatetimePostMockHandler(),
  getFormatNumberI18nFormatNumberPostMockHandler(),
  getFormatCurrencyI18nFormatCurrencyPostMockHandler(),
  getGetUserSettingsI18nUserSettingsGetMockHandler(),
  getUpdateUserSettingsI18nUserSettingsPutMockHandler(),
  getGetAgentContextI18nAgentContextGetMockHandler(),
  getGetAppInfoApiV1SystemInfoGetMockHandler(),
  getHealthCheckApiV1SystemHealthGetMockHandler()
]
